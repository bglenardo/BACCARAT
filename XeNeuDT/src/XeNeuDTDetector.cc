////////////////////////////////////////////////////////////////////////////////
//
// This code is automatically generated by BACCARAT to define XeNeu geometry
//
////////////////////////////////////////////////////////////////////////////////
//
//      Change log
// 17 March 2016 - Initial Template submission (Jingke)
//
////////////////////////////////////////////////////////////////////////////////

//
//      C/C++ includes
//
#include <sstream>
#include <ctime>

//
//      GEANT4 includes
//
#include "G4SystemOfUnits.hh"
#include "G4LogicalVolume.hh"
#include "G4Material.hh"
#include "G4NistManager.hh"
#include "G4RotationMatrix.hh"
#include "G4Tubs.hh"
#include "G4Box.hh"
#include "G4Torus.hh"
#include "G4CutTubs.hh"
#include "G4Ellipsoid.hh"
#include "G4Polyhedra.hh"
#include "G4Cons.hh"
#include "G4SubtractionSolid.hh"
#include "G4UnionSolid.hh"
#include "G4IntersectionSolid.hh"
#include "G4OpticalSurface.hh"
#include "G4LogicalBorderSurface.hh"

//
//      BACCARAT includes
//
#include "BaccManager.hh"
#include "BaccDetectorComponent.hh"
#include "BaccMaterials.hh"
#include "BaccSource.hh"
#include "BaccPhysicsOpticalPhysics.hh"
#include "BaccExample8778PMT.hh"

//
//      Project includes
//
#include "XeNeuDTDetector.hh"
#include "XeNeuDTMaterials.hh"
#include "XeNeuDTMessenger.hh"
//#include "XeNeu_XeDetectorParameters.hh"
#include "XeNeuDT_XeDetector.hh"
#include "XeNeu_PMTCage.hh"
#include "XeNeuDT_LSDetector.hh"
#include "XeNeu_DDCastle.hh"
#include "XeNeu_DDBoratedPoly_1.hh"
#include "XeNeu_DDBoratedPoly_2.hh"
#include "XeNeuDT_VacuumBox.hh"
#include "XeNeu_TUNLShielding.hh"
#include "XeNeu_DTShielding.hh"
#include "XeNeu_DDShieldingMigdal.hh"
//#include "XeNeu_MaterialTest.hh"
//#include "XeNeu_Sphere.hh"
#include "R8520PMT.hh"
//#include "AluminumTest.hh"
//
//		Definitions
//

//using namespace XeNeu_XeDetectorParameters;
using namespace std;


//------++++++------++++++------++++++------++++++------++++++------++++++------
//                          Detector Constructor
//------++++++------++++++------++++++------++++++------++++++------++++++------
XeNeuDTDetector::XeNeuDTDetector( G4String detName,
			G4String outVolName )
{
  detectorName = detName;
  outermostVolumeName = outVolName;
  
  XeNeumessenger = new XeNeuDTMessenger( this );
  
  //***DO NOT*** create another instance of XeNeuDTMaterials anywhere else!
  //Just refer to it using XeNeuDTMaterials::GetInstance().
  XeNeumaterials = XeNeuDTMaterials::GetInstance();
  if(!XeNeumaterials) XeNeumaterials = new XeNeuDTMaterials();
  //get the Bacc Materials and Nist materials
  NISTmaterials = G4NistManager::Instance();
  BACCmaterials = BaccMaterials::GetMaterials();
}

//------++++++------++++++------++++++------++++++------++++++------++++++------
//                          Detector Destructor
//------++++++------++++++------++++++------++++++------++++++------++++++------
XeNeuDTDetector::~XeNeuDTDetector()
{
  if(XeNeumessenger) delete XeNeumessenger;
  if(XeNeumaterials) delete XeNeumaterials;
}

//------++++++------++++++------++++++------++++++------++++++------++++++------
//                              InitializeDetector()
//------++++++------++++++------++++++------++++++------++++++------++++++------
void XeNeuDTDetector::InitializeDetector(){
  
  //if you need to access BaccManager
  BaccManager *BACCmanager = BaccManager::GetManager();
  
  //you can add the detector-specific source catalog here
  
}

//------++++++------++++++------++++++------++++++------++++++------++++++------
//                              BuildDetector()
//------++++++------++++++------++++++------++++++------++++++------++++++------
void XeNeuDTDetector::BuildDetector(){
  InitializeDetector();

//XeNeu_Sphere * Sphere_obj = new XeNeu_Sphere();
//logicalVolume = Sphere_obj->GetLogicalVolume();

//  R8520PMT * PMT_obj = new R8520PMT();
//  logicalVolume = PMT_obj->GetLogicalVolume(); 

//  XeNeu_PMTCage * PMTCage_Obj = new XeNeu_PMTCage();
//  logicalVolume = PMTCage_Obj->GetLogicalVolume(); 

//  XeNeu_XeDetector * detector_obj = new XeNeu_XeDetector();
//  logicalVolume = detector_obj->GetLogicalVolume();

//  AluminumTest * Aluminum_obj = new AluminumTest();
//  logicalVolume = Aluminum_obj->GetLogicalVolume();

//	XeNeu_DTShielding * dt_shield_obj = new XeNeu_DTShielding();
//	logicalVolume = dt_shield_obj->GetLogicalVolume();

//this is how you access your material definition
//  G4cout<<"XeNeuDTMaterials example"<<G4endl;
//  G4cout<<XeNeumaterials->GetMaterialByName("liquidXe")<<G4endl<<G4endl;
 
  //Alternatively you can use the nist material database
//  G4cout<<"NistMaterials example"<<G4endl;
//  G4cout<< NISTmaterials->FindOrBuildMaterial("G4_lXe")<<G4endl<<G4endl;
  
  //another way is to use BaccMaterials
//  G4cout<<"BaccMaterials example"<<G4endl;
//  G4cout<<BACCmaterials->LiquidXe()<<G4endl<<G4endl;
 
  //  Remember that the outermost vessel is defined as a LUXSimDetector
  //	"logicalVolume".
  //build your detector here    
/*
  //Create a Sphere Around the DT Shielding to isolate its effects
  G4Box * DTShielding_Measurement = new G4Box("DTShielding_Measurement", 4*m, 4*m, 4*m);
  G4LogicalVolume *  DTShielding_Measurement_log = new G4LogicalVolume(DTShielding_Measurement, BACCmaterials->Vacuum(), "DTShielding_Measurement_log");
  DTShielding_Measurement_log->SetVisAttributes(BACCmaterials->WaterVis());
  BaccDetectorComponent * DTShielding_Measurement_object = new BaccDetectorComponent(0,G4ThreeVector(0.,0.,0.),DTShielding_Measurement_log, "DTShielding_Measurement_object", logicalVolume, 0,0,true); 
*/
//Create Laboratory Space
  G4Box * laboratory = new G4Box("laboratory", 8 * m, 8 * m, 8 * m);
  logicalVolume  = new G4LogicalVolume(laboratory, BACCmaterials->Air(), "laboratory");
  logicalVolume->SetVisAttributes( BACCmaterials->VacuumVis() );


// Create the DT Shielding object
if( dtShieldingOn ) {

// XeNeu_DTShielding * dt_shield_obj = new XeNeu_DTShielding();  
 XeNeu_DDShieldingMigdal * dt_shield_obj = new XeNeu_DDShieldingMigdal();
// ShieldingVolume = dt_shield_obj->GetLogicalVolume();
  // double source_detector_distance = 1.8236 * m; // Value in DT recoil measurement
  double source_detector_distance = 1.5236 * m;
 
  BaccDetectorComponent * dt_shield = new BaccDetectorComponent(0,
                                            G4ThreeVector(source_detector_distance,.3*m,0),
                                            dt_shield_obj->GetLogicalVolume(),
                                            "dt_shield",
                                            logicalVolume,
                                            0,0,true);
  bool is_first_DT_Sept2021 = false; 
  bool dt_Migdal_Run_RandD = false;
  bool dt_Migdal_Run_14det_17deg = true;

  G4Box * floor_box = new G4Box("floor_box",5.*m, 5.*m, 0.5*m);
  G4LogicalVolume * floor_log = new G4LogicalVolume( floor_box, BACCmaterials->PortlandConcrete(), "floor_log" );
  floor_log->SetVisAttributes( BACCmaterials->TestRedVis() );  
    BaccDetectorComponent * concrete_floor = new BaccDetectorComponent(0,
                                                 G4ThreeVector(0,0,-(50.*cm + 83.82*cm)),
                                                 floor_log,
                                                 "concrete_floor",
                                                 logicalVolume, 0,0,true); 



  if( is_first_DT_Sept2021 ) { 
   
      // Build the liquid scintillator detectors
      // 180 deg is straight in front of the DT Beam 
      double d_LS1 =  54.53 * cm + 3.94 * 2.54 * cm + 4.5 * 2.54 *cm;
      double d_LS2 = 18.89*cm + 3.94 * 2.54 * cm + 4.5 * 2.54 *cm;//11.43 added (probably length of inner xenon to OD)
      double d_LS3 = 25.4*cm + 3.94 * 2.54 * cm + 4.5 * 2.54 *cm;//11.43 added (probably length of LS detector?)
      double d_LS4 = 13.66*cm +3.94 * 2.54 * cm + 4.5 * 2.54 *cm;//11.43 added (probably length of LS detector?)
      double d_LS5 =  7.315*cm + 3.94 * 2.54 * cm + 4.5 * 2.54 *cm;//11.43 added (probably length of LS detector?)
      double d_LS6 =  25.15*cm +3.94 * 2.54 * cm + 4.5 * 2.54 *cm;//11.43 added (probably length of LS detector?)
      double d_LS7 = 15.78*cm + 3.94 * 2.54 * cm + 4.5 * 2.54 *cm ;//11.43 added (probably length of LS detector?)
      double d_LS8 = 14.33*cm + 3.94 * 2.54 * cm + 4.5 * 2.54 *cm;//11.43 added (probably length of LS detector?)

      double backingDetectorAngle_1 = 17.*deg;
      double backingDetectorAngle_2 = 92.*deg;
      double backingDetectorAngle_3 = 50.*deg;
      double backingDetectorAngle_4 = -67.*deg;
      double backingDetectorAngle_5 = -115.*deg;
      double backingDetectorAngle_6 = -36.*deg;
      double backingDetectorAngle_7 = 140.*deg;
      double backingDetectorAngle_8 = -162.*deg;

      G4RotationMatrix * rotm_ls_1 = new G4RotationMatrix();
      rotm_ls_1->rotateX(90.*deg);
      rotm_ls_1->rotateY(90.*deg + backingDetectorAngle_1);
    
      G4RotationMatrix * rotm_ls_2 = new G4RotationMatrix();
      rotm_ls_2->rotateX(90.*deg);
      rotm_ls_2->rotateY(90.*deg + backingDetectorAngle_2);

      G4RotationMatrix * rotm_ls_3 = new G4RotationMatrix();
      rotm_ls_3->rotateX(90.*deg);
      rotm_ls_3->rotateY(90.*deg + backingDetectorAngle_3);

      G4RotationMatrix * rotm_ls_4 = new G4RotationMatrix();
      rotm_ls_4->rotateX(90.*deg);
      rotm_ls_4->rotateY(90.*deg + backingDetectorAngle_4);

      G4RotationMatrix * rotm_ls_5 = new G4RotationMatrix();
      rotm_ls_5->rotateX(90.*deg);
      rotm_ls_5->rotateY(90.*deg + backingDetectorAngle_5);

      G4RotationMatrix * rotm_ls_6 = new G4RotationMatrix();
      rotm_ls_6->rotateX(90.*deg);
      rotm_ls_6->rotateY(90.*deg + backingDetectorAngle_6);

      G4RotationMatrix * rotm_ls_7 = new G4RotationMatrix();
      rotm_ls_7->rotateX(90.*deg);
      rotm_ls_7->rotateY(90.*deg + backingDetectorAngle_7);

      G4RotationMatrix * rotm_ls_8 = new G4RotationMatrix();
      rotm_ls_8->rotateX(90.*deg);
      rotm_ls_8->rotateY((90.*deg + backingDetectorAngle_8));

      double PI = 3.1415927;

      double bdAngRad_1 = backingDetectorAngle_1/deg/180. * PI;
      double bdAngRad_2 = backingDetectorAngle_2/deg/180. * PI;
      double bdAngRad_3 = backingDetectorAngle_3/deg/180. * PI;
      double bdAngRad_4 = backingDetectorAngle_4/deg/180. * PI;
      double bdAngRad_5 = backingDetectorAngle_5/deg/180. * PI;
      double bdAngRad_6 = backingDetectorAngle_6/deg/180. * PI;
      double bdAngRad_7 = backingDetectorAngle_7/deg/180. * PI;
      double bdAngRad_8 = backingDetectorAngle_8/deg/180. * PI;
 
      XeNeuDT_LSDetector * ls_detector_1_obj = new XeNeuDT_LSDetector(1);
      BaccDetectorComponent * ls_detector_1 = new BaccDetectorComponent(rotm_ls_1,
                                                           G4ThreeVector(-d_LS1*cos(bdAngRad_1),-d_LS1*sin(bdAngRad_1),0.),
                                                           ls_detector_1_obj->GetLogicalVolume(),
                                                           "ls_detector_1",
                                                           logicalVolume,
                                                           0,0,true);
 
      XeNeuDT_LSDetector * ls_detector_2_obj = new XeNeuDT_LSDetector(2);
      BaccDetectorComponent * ls_detector_2 = new BaccDetectorComponent(rotm_ls_2,
                                                           G4ThreeVector(-d_LS2*cos(bdAngRad_2),-d_LS2*sin(bdAngRad_2),0.),
                                                           ls_detector_2_obj->GetLogicalVolume(),
                                                           "ls_detector_2",
                                                           logicalVolume,
                                                           0,0,true);

      XeNeuDT_LSDetector * ls_detector_3_obj = new XeNeuDT_LSDetector(3);
      BaccDetectorComponent * ls_detector_3 = new BaccDetectorComponent(rotm_ls_3,
                                                           G4ThreeVector(-d_LS3*cos(bdAngRad_3),-d_LS3*sin(bdAngRad_3),0.),
                                                           ls_detector_3_obj->GetLogicalVolume(),
                                                           "ls_detector_3",
                                                           logicalVolume,
                                                           0,0,true);

      XeNeuDT_LSDetector * ls_detector_4_obj = new XeNeuDT_LSDetector(4);
      BaccDetectorComponent * ls_detector_4 = new BaccDetectorComponent(rotm_ls_4,
                                                           G4ThreeVector(-d_LS4*cos(bdAngRad_4),-d_LS4*sin(bdAngRad_4),0.),
                                                           ls_detector_4_obj->GetLogicalVolume(),
                                                           "ls_detector_4",
                                                           logicalVolume,
                                                           0,0,true);


      XeNeuDT_LSDetector * ls_detector_5_obj = new XeNeuDT_LSDetector(5);
      BaccDetectorComponent * ls_detector_5 = new BaccDetectorComponent(rotm_ls_5,
                                                           G4ThreeVector(-d_LS5*cos(bdAngRad_5),-d_LS5*sin(bdAngRad_5),0.),
                                                           ls_detector_5_obj->GetLogicalVolume(),
                                                           "ls_detector_5",
                                                           logicalVolume,
                                                           0,0,true);

      XeNeuDT_LSDetector * ls_detector_6_obj = new XeNeuDT_LSDetector(6);
      BaccDetectorComponent * ls_detector_6 = new BaccDetectorComponent(rotm_ls_6,
                                                           G4ThreeVector(-d_LS6*cos(bdAngRad_6),-d_LS6*sin(bdAngRad_6),0.),
                                                           ls_detector_6_obj->GetLogicalVolume(),
                                                           "ls_detector_6",
                                                           logicalVolume,
                                                           0,0,true);

      XeNeuDT_LSDetector * ls_detector_7_obj = new XeNeuDT_LSDetector(7);
      BaccDetectorComponent * ls_detector_7 = new BaccDetectorComponent(rotm_ls_7,
                                                           G4ThreeVector(- d_LS7*cos(bdAngRad_7), -d_LS7*sin(bdAngRad_7),0.),
                                                           ls_detector_7_obj->GetLogicalVolume(),
                                                           "ls_detector_7",
                                                           logicalVolume,
                                                           0,0,true);

      XeNeuDT_LSDetector * ls_detector_8_obj = new XeNeuDT_LSDetector(8);
      BaccDetectorComponent * ls_detector_8 = new BaccDetectorComponent(rotm_ls_8,
                                                           G4ThreeVector(-(d_LS8)*cos(bdAngRad_8),-(d_LS8)*sin(bdAngRad_8),0.),
                                                           ls_detector_8_obj->GetLogicalVolume(),
                                                           "ls_detector_8",
                                                           logicalVolume,
                                                           0,0,true);

   } else if( dt_Migdal_Run_RandD ){

      // Here we want to model an experiment where all the detectors are at the same angle.
      // To start, I'll put two detectors at the 17deg, nominal distance, then 

      double d_LS1 =  54.53 * cm + 3.94 * 2.54 * cm + 4.5 * 2.54 *cm;
      d_LS1 = d_LS1 * 1.5;

      double backingDetectorAngle_1 = 17.*deg;

      G4RotationMatrix * rotm_ls_1 = new G4RotationMatrix();
      rotm_ls_1->rotateX(90.*deg);
      rotm_ls_1->rotateY(90.*deg + backingDetectorAngle_1);

      double PI = 3.1415927;
      double bdAngRad_1 = backingDetectorAngle_1/deg/180. * PI;

      XeNeuDT_LSDetector * ls_detector_1_obj = new XeNeuDT_LSDetector(1);

      BaccDetectorComponent * ls_detector_1 = new BaccDetectorComponent(rotm_ls_1,
                                                           G4ThreeVector(-d_LS1*cos(bdAngRad_1),-d_LS1*sin(bdAngRad_1),0.),
                                                           ls_detector_1_obj->GetLogicalVolume(),
                                                           "ls_detector_1",
                                                           logicalVolume,
                                                           0,0,true);
      
      // Detector 2 is at the same distance/angle as detector 1, 
      // just at the opposite position in the horizontal plane.
      G4RotationMatrix * rotm_ls_2 = new G4RotationMatrix();
      rotm_ls_2->rotateX(90.*deg);
      rotm_ls_2->rotateY(90.*deg - backingDetectorAngle_1);

      XeNeuDT_LSDetector * ls_detector_2_obj = new XeNeuDT_LSDetector(2);

      BaccDetectorComponent * ls_detector_2 = new BaccDetectorComponent(rotm_ls_2,
                                                           G4ThreeVector(-d_LS1*cos(bdAngRad_1),d_LS1*sin(bdAngRad_1),0.),
                                                           ls_detector_2_obj->GetLogicalVolume(),
                                                           "ls_detector_2",
                                                           logicalVolume,
                                                           0,0,true);


      // Detector 3 is above in the vertical plane.
      G4RotationMatrix * rotm_ls_3 = new G4RotationMatrix();
      rotm_ls_3->rotateY(90.*deg - backingDetectorAngle_1);
      //rotm_ls_3->rotateX(90.*deg - backingDetectorAngle_1);

      XeNeuDT_LSDetector * ls_detector_3_obj = new XeNeuDT_LSDetector(3);

      BaccDetectorComponent * ls_detector_3 = new BaccDetectorComponent(rotm_ls_3,
                                                           G4ThreeVector(-d_LS1*cos(bdAngRad_1),0.,d_LS1*sin(bdAngRad_1)),
                                                           ls_detector_3_obj->GetLogicalVolume(),
                                                           "ls_detector_3",
                                                           logicalVolume,
                                                           0,0,true);

      // Detector 4 is above in the vertical plane.
      G4RotationMatrix * rotm_ls_4 = new G4RotationMatrix();
      rotm_ls_4->rotateY(90.*deg + backingDetectorAngle_1);
      //rotm_ls_4->rotateX(90.*deg + backingDetectorAngle_1);

      XeNeuDT_LSDetector * ls_detector_4_obj = new XeNeuDT_LSDetector(4);

      BaccDetectorComponent * ls_detector_4 = new BaccDetectorComponent(rotm_ls_4,
                                                           G4ThreeVector(-d_LS1*cos(bdAngRad_1),0.,-d_LS1*sin(bdAngRad_1)),
                                                           ls_detector_4_obj->GetLogicalVolume(),
                                                           "ls_detector_4",
                                                           logicalVolume,
                                                           0,0,true);


   } else if( dt_Migdal_Run_14det_17deg ) {
 
      // Commented out for real DT Migdal run August 2022 
      //double scattering_angle = 17.*deg;
      //double ls_Distance = 1. * m;
      //double ls_DistanceX = - ls_Distance * cos( scattering_angle );
      
      // Hardcoded dimension of true Migdal Run August 2022:
      // 95cm from center of TPC to the front faces of the LS detectors
      //double ls_DistanceX = -1.*(95.0 * cm + 4.5 * 2.54*cm); // Distance for DT generator
      double ls_DistanceX = -1.*(50.0 * cm + 4.5 * 2.54*cm); // Distance for DD generator
      double ls_ring_radius = 26.5 * cm;

      G4RotationMatrix * rotm_ls = new G4RotationMatrix();
      rotm_ls->rotateX(90.*deg);
      rotm_ls->rotateY(90.*deg);

      BaccDetectorComponent * ls_detectors[14];
      XeNeuDT_LSDetector * ls_det_temp;

      for(int i=0; i<14; i++){
          //G4RotationMatrix * rotm = new G4RotationMatrix();
          char detector_name[100];
          sprintf(detector_name,"ls_detector_%d",i);
          double ls_det_z_angle = 360.*deg / 14 * i;
          ls_det_temp = new XeNeuDT_LSDetector(i);
          ls_detectors[i] = new BaccDetectorComponent(rotm_ls,
                                                      G4ThreeVector( ls_DistanceX,
                                                                     ls_ring_radius * sin( ls_det_z_angle ),
                                                                     ls_ring_radius * cos( ls_det_z_angle )),
                                                      ls_det_temp->GetLogicalVolume(),
                                                      detector_name,
                                                      logicalVolume,
                                                      0,0,true);
      }      


   }


} 
  G4RotationMatrix * det_rot = new G4RotationMatrix();
   det_rot->rotateZ(0.*deg);
  double detector_Z = 1.*cm;
// Build the liquid xenon detector and stuff
  XeNeuDT_XeDetector * detector_obj = new XeNeuDT_XeDetector();
  BaccDetectorComponent * detector = new BaccDetectorComponent(det_rot, 
                                                       G4ThreeVector(0,0,detector_Z),
                                                       detector_obj->GetLogicalVolume(),
                                                       "detector",
                                                       logicalVolume,
                                                        0, 0, true);


  // Build the vacuum box
  double detectorHalfHeight = 7. * 2.54 * cm; 
  double vacuumBoxHalfHeight = 3. * 2.54 * cm; 
  double vacuumBoxHole_Y = (11. - 5.)*2.54 * cm;

  XeNeuDT_VacuumBox * vacuum_box_obj = new XeNeuDT_VacuumBox();
  BaccDetectorComponent * vacuum_box = new BaccDetectorComponent(det_rot,
                                        G4ThreeVector(0.,
                                                      -vacuumBoxHole_Y,
                                                      detector_Z + detectorHalfHeight + vacuumBoxHalfHeight),
                                        vacuum_box_obj->GetLogicalVolume(),
                                        "vacuum_box",
                                        logicalVolume,
                                        0,0,true);







  // Build the aluminum base plate
  double baseplateHalfWidth = 15. * 2.54 * cm / 2.;
  double baseplateHalfLength = 26. * 2.54 * cm / 2.;
  double baseplateHalfHeight = 0.375 * 2.54 * cm / 2.;
  double baseplateHoleRadius = 5.5 * 2.54 * cm;

  G4Box * baseplate_solid = new G4Box("baseplate_solid",
                                      baseplateHalfWidth,
                                      baseplateHalfLength,
                                      baseplateHalfHeight);
  G4Tubs * baseplate_hole = new G4Tubs("baseplate_hole",
                                      0.*cm,
                                      baseplateHoleRadius,
                                      baseplateHalfHeight * 2.,
                                      0.*deg,360.*deg);
  G4SubtractionSolid * baseplate_total_solid = new G4SubtractionSolid("baseplate_total_solid",
                                      baseplate_solid,
                                      baseplate_hole,
                                      0,G4ThreeVector(0.,5.5*2.54*cm,0.));
  G4LogicalVolume * baseplate_log = new G4LogicalVolume( baseplate_total_solid, BACCmaterials->Aluminum(), "baseplate_log");
  BaccDetectorComponent * al_baseplate = new BaccDetectorComponent(0,
                                      G4ThreeVector(0.,-5.5*2.54*cm,detector_Z - detectorHalfHeight - baseplateHalfHeight - 2. * 2.54 * cm ),
                                       baseplate_log,
                                      "al_baseplate",
                                      logicalVolume,0,0,true);
 
 // Build the aluminum detector supports
 double supportRadius = 1.5/2. * 2.54 * cm;
 double supportHalfHeight = 16. * 2.54 * cm / 2.; 
 double sideSupportXOffset = baseplateHalfWidth - 0.75 * 2.54 * cm;
 double sideSupportYOffset = -(22. - 5.) * 2.54 * cm;
 double frontSupportYOffset  = (5.5 + 2. - 0.75) * 2.54 * cm;
  
 G4Tubs * al_detector_support = new G4Tubs("al_detector_suport",
                                      0.*cm,
                                      supportRadius,
                                      supportHalfHeight,
                                      0.*deg,360.*deg);
 G4LogicalVolume * al_support_log = new G4LogicalVolume( al_detector_support, BACCmaterials->Aluminum(), "al_support_log");
 BaccDetectorComponent * al_detector_support_1 = new BaccDetectorComponent(0,
                                      G4ThreeVector( 0., frontSupportYOffset, detector_Z - detectorHalfHeight - 2. * 2.54 * cm + supportHalfHeight),
                                      al_support_log,
                                      "al_detector_support_1",
                                      logicalVolume,
                                      0,0,true);
 BaccDetectorComponent * al_detector_support_2 = new BaccDetectorComponent(0,
                                      G4ThreeVector( sideSupportXOffset, sideSupportYOffset, detector_Z - detectorHalfHeight - 2. * 2.54 * cm + supportHalfHeight),
                                      al_support_log,
                                      "al_detector_support_2",
                                      logicalVolume,
                                      0,0,true);
 BaccDetectorComponent * al_detector_support_3 = new BaccDetectorComponent(0,
                                      G4ThreeVector( -sideSupportXOffset, sideSupportYOffset, detector_Z - detectorHalfHeight - 2. * 2.54 * cm + supportHalfHeight),
                                      al_support_log,
                                      "al_detector_support_3",
                                      logicalVolume,
                                      0,0,true);


      // Build the lead shielding around the detector 
      double detectorOuterRadius  = 4.* 2.54 * cm;
      double shieldThickness = 0.476 * cm;
    
      G4Tubs * pb_det_shield_1_tubs = new G4Tubs("pb_det_shield_1_tubs",
                                           detectorOuterRadius,
                                           detectorOuterRadius + shieldThickness,
                                           detectorHalfHeight,
                                           0.*deg,
                                           180.*deg);

      G4Box * front_hole_box = new G4Box("front_hole_box",0.75*2.54*cm,1.*2.54*cm,0.75*2.54*cm);
      G4SubtractionSolid * pb_shield_minus_front_hole = new G4SubtractionSolid("pb_shield_minus_front_hole",
                                                        pb_det_shield_1_tubs,front_hole_box,0,G4ThreeVector(0,4.*2.54*cm,-1.*cm));
      
      G4LogicalVolume * pb_det_shield_1_log = new G4LogicalVolume(pb_shield_minus_front_hole,
                                           BACCmaterials->Lead(),
                                            "pb_det_shield_1_log");
      pb_det_shield_1_log->SetVisAttributes( BACCmaterials->TestPurpleVis() );
      G4RotationMatrix * rotm_pb_wrap = new G4RotationMatrix();
      rotm_pb_wrap->rotateZ( 90.*deg );
      BaccDetectorComponent * pb_det_shield_1 = new BaccDetectorComponent(rotm_pb_wrap,
                                           G4ThreeVector(0,0,detector_Z),
                                           pb_det_shield_1_log,
                                           "pb_det_shield_1",
                                           logicalVolume,
                                           0,0,true);

      G4Box * pb_brick_1in_box = new G4Box("pb_brick_1in_box",
                                            0.5 * 2.54*cm,
                                            2. * 2.54*cm,
                                            4. * 2.54*cm);
      G4LogicalVolume * pb_brick_1in_log = new G4LogicalVolume(pb_brick_1in_box,
                                                               BACCmaterials->Lead(),
                                                               "pb_brick_1in_log");
      pb_brick_1in_log->SetVisAttributes( BACCmaterials->TestRedVis() );

      double brick_1in_radius = 4.25 * 2.54 * cm + 0.5*2.54*cm;

      double brick_1_angle = 34.4 * deg;
      G4RotationMatrix * rotm_pb_brick_1 = new G4RotationMatrix();
      rotm_pb_brick_1->rotateZ( -1.*brick_1_angle );
      BaccDetectorComponent * pb_brick_1in_1 = new BaccDetectorComponent(rotm_pb_brick_1,
                                                       G4ThreeVector( brick_1in_radius * cos(brick_1_angle),
                                                                      brick_1in_radius * sin(brick_1_angle),
                                                                      detector_Z),
                                                       pb_brick_1in_log,
                                                       "pb_brick_1in_1",
                                                       logicalVolume,
                                                       0,0,true);
      double brick_2_angle = 34.4 * deg + 2*25.2 * deg;
      G4RotationMatrix * rotm_pb_brick_2 = new G4RotationMatrix();
      rotm_pb_brick_2->rotateZ( -1.*brick_2_angle );
      BaccDetectorComponent * pb_brick_1in_2 = new BaccDetectorComponent(rotm_pb_brick_2,
                                                       G4ThreeVector( brick_1in_radius * cos(brick_2_angle),
                                                                      brick_1in_radius * sin(brick_2_angle),
                                                                      detector_Z),
                                                       pb_brick_1in_log,
                                                       "pb_brick_1in_2",
                                                       logicalVolume,
                                                       0,0,true);
      double brick_3_angle = -34.4 * deg;
      G4RotationMatrix * rotm_pb_brick_3 = new G4RotationMatrix();
      rotm_pb_brick_3->rotateZ( -1.*brick_3_angle );
      BaccDetectorComponent * pb_brick_1in_3 = new BaccDetectorComponent(rotm_pb_brick_3,
                                                       G4ThreeVector( brick_1in_radius * cos(brick_3_angle),
                                                                      brick_1in_radius * sin(brick_3_angle),
                                                                      detector_Z),
                                                       pb_brick_1in_log,
                                                       "pb_brick_1in_3",
                                                       logicalVolume,
                                                       0,0,true);
      double brick_4_angle = -34.4 * deg - 2*25.2 * deg;
      G4RotationMatrix * rotm_pb_brick_4 = new G4RotationMatrix();
      rotm_pb_brick_4->rotateZ( -1.*brick_4_angle );
      BaccDetectorComponent * pb_brick_1in_4 = new BaccDetectorComponent(rotm_pb_brick_4,
                                                       G4ThreeVector( brick_1in_radius * cos(brick_4_angle),
                                                                      brick_1in_radius * sin(brick_4_angle),
                                                                      detector_Z),
                                                       pb_brick_1in_log,
                                                       "pb_brick_1in_4",
                                                       logicalVolume,
                                                       0,0,true);

     
     double large_brick_distance =  (5.75 + 1.) * 2.54 * cm;
     G4Box * large_brick_box = new G4Box("large_brick_box", 1.*2.54*cm, 4.*2.54*cm, 2.*2.54*cm);
     G4LogicalVolume * large_brick_log = new G4LogicalVolume(large_brick_box, BACCmaterials->Lead(),"large_brick_log");
     large_brick_log->SetVisAttributes( BACCmaterials->TestPurpleVis() );
     BaccDetectorComponent * large_pb_brick = new BaccDetectorComponent(0, 
                                                                        G4ThreeVector(large_brick_distance,
                                                                                     0., detector_Z-(2.75 * 2.54 * cm)),
                                                                        large_brick_log,
                                                                        "large_pb_brick",
                                                                        logicalVolume,
                                                                        0,0,true);
    
     G4Box * thin_pb_sheet_box = new G4Box("thin_pb_sheet_box", 3.*mm / 2., 20.*cm, 20*cm);
     G4LogicalVolume * thin_pb_sheet_log = new G4LogicalVolume( thin_pb_sheet_box, BACCmaterials->Lead(), "thin_pb_sheet_log");
     thin_pb_sheet_log->SetVisAttributes( BACCmaterials->TestGreenVis() );
     BaccDetectorComponent * thin_pb_sheet = new BaccDetectorComponent(0,
                                                              G4ThreeVector(9.*2.54*cm, 0., 0.),
                                                              thin_pb_sheet_log,
                                                              "thin_pb_sheet",
                                                              logicalVolume,
                                                              0,0,true);     





  return;
/*
  if( ddShieldingOn ) {

      // Build the lead shielding around the detector 
      double detectorOuterRadius  = 4.* 2.54 * cm;
      double shieldThickness = 0.5 * cm;
      double openingAngle = 14.*deg;
    
      G4Tubs * pb_det_shield_1_tubs = new G4Tubs("pb_det_shield_1_tubs",
                                           detectorOuterRadius,
                                           detectorOuterRadius + shieldThickness,
                                           detectorHalfHeight,
                                           -180*deg + openingAngle/2.,
                                           180.*deg + backingDetectorAngle - openingAngle);
      G4LogicalVolume * pb_det_shield_1_log = new G4LogicalVolume(pb_det_shield_1_tubs,
                                           BACCmaterials->Lead(),
                                            "pb_det_shield_1_log");
      pb_det_shield_1_log->SetVisAttributes( BACCmaterials->LeadVis() );
      //pb_det_shield_1_log->SetVisAttributes( BACCmaterials->VacuumVis() );
      BaccDetectorComponent * pb_det_shield_1 = new BaccDetectorComponent(0,
                                           G4ThreeVector(0,0,detector_Z),
                                           pb_det_shield_1_log,
                                           "pb_det_shield_1",
                                           logicalVolume,
                                           0,0,true);
    
      G4Tubs * pb_det_shield_2_tubs = new G4Tubs("pb_det_shield_2_tubs",
                                           detectorOuterRadius,
                                           detectorOuterRadius + shieldThickness,
                                           detectorHalfHeight,
                                           backingDetectorAngle + openingAngle/2.,
                                           180.*deg - backingDetectorAngle - openingAngle);
      G4LogicalVolume * pb_det_shield_2_log = new G4LogicalVolume(pb_det_shield_2_tubs,
                                           BACCmaterials->Lead(),
                                            "pb_det_shield_1_log");
      pb_det_shield_2_log->SetVisAttributes( BACCmaterials->LeadVis() );
      //pb_det_shield_2_log->SetVisAttributes( BACCmaterials->VacuumVis() );
      BaccDetectorComponent * pb_det_shield_2 = new BaccDetectorComponent(0,
                                           G4ThreeVector(0,0,detector_Z),
                                           pb_det_shield_2_log,
                                           "pb_det_shield_2",
                                           logicalVolume,
                                           0,0,true);
    
    
      // Build the liquid scintillator detectors
      double d_LS = 44.*cm + 4.5 * 2.54 * cm;
    
      G4RotationMatrix * rotm_ls_1 = new G4RotationMatrix();
      rotm_ls_1->rotateX(90.*deg);
      rotm_ls_1->rotateY(-(90.*deg-backingDetectorAngle));
    
      G4RotationMatrix * rotm_ls_2 = new G4RotationMatrix();
      rotm_ls_2->rotateX(90.*deg);
      rotm_ls_2->rotateY(-90.*deg - backingDetectorAngle);
    
      double bdAngRad = backingDetectorAngle/deg/180. * PI;
    
      XeNeuDT_LSDetector * ls_detector_obj = new XeNeuDT_LSDetector();
      BaccDetectorComponent * ls_detector_1 = new BaccDetectorComponent(rotm_ls_1,
                                                           G4ThreeVector(d_LS*cos(bdAngRad),d_LS*sin(bdAngRad),0.),
                                                           ls_detector_obj->GetLogicalVolume(),
                                                           "ls_detector_1",
                                                           logicalVolume,
                                                           0,0,true);
    
      BaccDetectorComponent * ls_detector_2 = new BaccDetectorComponent(rotm_ls_2,
                                                           G4ThreeVector(d_LS*cos(-bdAngRad),d_LS*sin(-bdAngRad),0.),
                                                           ls_detector_obj->GetLogicalVolume(),
                                                           "ls_detector_2",
                                                           logicalVolume,
                                                           0,0,true);
      
    
      // Build the DD shielding castle setup
      XeNeu_DDCastle * dd_castle_obj = new XeNeu_DDCastle();
      BaccDetectorComponent * dd_castle = new BaccDetectorComponent(0,
                                                           G4ThreeVector(-42.*cm,-5.625 * 2.54 * cm,0.),
                                                           dd_castle_obj->GetLogicalVolume(),
                                                           "dd_castle",
                                                           logicalVolume,
                                                           0,0,true);
    
      XeNeu_DDBoratedPoly_1 * b_poly_1_obj = new XeNeu_DDBoratedPoly_1();
    
      double boratedPoly_1_X = -42.*cm + 8.*2.54*cm + (4*2.54*cm + 0.5*cm)/2. + 5.*cm;
      double boratedPoly_1_Y = -(27.*cm/2. + 3.75*2.54*cm);
      BaccDetectorComponent * b_poly_1 = new BaccDetectorComponent(0,
                                                             G4ThreeVector(boratedPoly_1_X,boratedPoly_1_Y,0.),
                                                             b_poly_1_obj->GetLogicalVolume(),
                                                             "b_poly_1",
                                                             logicalVolume,0,0,true);
    
    
    
      XeNeu_DDBoratedPoly_2 * b_poly_2_obj = new XeNeu_DDBoratedPoly_2();
    
      double borated_poly_2_X = -42.*cm + 8.*2.54*cm + (2*2.54*cm + 1.*cm)/2.;
      double borated_poly_2_Y = 0.5*2.54*cm + 31.*cm/2.;
      BaccDetectorComponent * b_poly_2 = new BaccDetectorComponent(0,
                                                             G4ThreeVector(borated_poly_2_X,borated_poly_2_Y,0.),
                                                             b_poly_2_obj->GetLogicalVolume(),
                                                             "b_poly_2",
                                                             logicalVolume,0,0,true);
                                                        
  }
*/
//-------------------------------------------------------------------------------------------------------------------//
//                                         	REFLECTIVITY TESTS						     //
//-------------------------------------------------------------------------------------------------------------------//                                         	
/*
  G4Box * detectorVolume_box = new G4Box("detector", 8.5 * cm, 8.5 * cm, 8.5 * cm);

  G4LogicalVolume * detectorVolume_log = new G4LogicalVolume(detectorVolume_box, BACCmaterials->GasXe(),"detectorVolume_log");

//  detectorVolume_log->SetVisAttributes(BACCmaterials->SteelVis());


  G4Box * vacuumbox = new G4Box("vacuumbox", 8. * cm, 8. * cm, 8. * cm);

  G4LogicalVolume * vacuumbox_log = new G4LogicalVolume(vacuumbox, BACCmaterials->LiquidXe(),"vacuumbox_log");
 
*/
/*
 G4Box * measurementbox = new G4Box("measurementbox", 8. * cm, 8. * cm, 1 * mm);
  G4LogicalVolume * measurementbox_log = new G4LogicalVolume(measurementbox, BACCmaterials->LiquidXe(),"measurementbox_log");

  measurementbox_log->SetVisAttributes(BACCmaterials->WaterVis());

  BaccDetectorComponent * measurementbox_obj = new BaccDetectorComponent(0,
                                                                  G4ThreeVector(0,0,0),
                                                                  measurementbox_log,
                                                                  "measurementbox_obj",
                                                                  vacuumbox_log,
                                                                  0,0,true);
*/
/*
  BaccDetectorComponent * vacuumbox_obj = new BaccDetectorComponent(0,
                                                                  G4ThreeVector(0,0,0),
                                                                  vacuumbox_log,
                                                                  "vacuumbox_obj",
                                                                  detectorVolume_log,
                                                                  0,0,true);


  BaccDetectorComponent * detectorVolume_obj = new BaccDetectorComponent(0,
  								G4ThreeVector(0,0,0),
  								detectorVolume_log,
  								"detectorVolume_obj",
  								logicalVolume,
  								0,0,true);
*/
/*
         G4LogicalBorderSurface *teflonLXeSurface;

         teflonLXeSurface = new G4LogicalBorderSurface(
         				                "teflonLXeSurface",
							 vacuumbox_obj,
							 detectorVolume_obj,
							 baccMaterials->LXeTeflonSurface() );
*/
//G4OpticalSurface * teflonLXeSurface = new G4OpticalSurface("teflonLXeSurface", detectorVolume_obj, vacuumbox_obj, dielectric_dielectric);
//teflonLXeSurface->SetMaterialPropertiesTable(baccMaterials->LXeTeflonSurface() );

}






//------++++++------++++++------++++++------++++++------++++++------++++++------
//                                      SetOrigin()
//------++++++------++++++------++++++------++++++------++++++------++++++------
G4ThreeVector XeNeuDTDetector::SetOrigin(BaccDetectorComponent *ExpHall){
  //you need to implement this function here
  return G4ThreeVector(0,0,0);
}
