////////////////////////////////////////////////////////////////////////////////
//
// This code is automatically generated by BACCARAT to define XeNeu geometry
//
////////////////////////////////////////////////////////////////////////////////
//
//      Change log
// 17 March 2016 - Initial Template submission (Jingke)
//
////////////////////////////////////////////////////////////////////////////////

//
//      C/C++ includes
//
#include <sstream>
#include <ctime>
#include <cmath>

//
//      GEANT4 includes
//
#include "G4SystemOfUnits.hh"
#include "G4LogicalVolume.hh"
#include "G4Material.hh"
#include "G4NistManager.hh"
//#include "G4RotationMatrix.hh"
#include "G4Tubs.hh"
#include "G4Box.hh"
//#include "G4Torus.hh"
//#include "G4CutTubs.hh"
//#include "G4Ellipsoid.hh"
//#include "G4Polyhedra.hh"
//#include "G4Cons.hh"
#include "G4SubtractionSolid.hh"
//#include "G4UnionSolid.hh"
//#include "G4IntersectionSolid.hh"
//#include "G4OpticalSurface.hh"
//#include "G4LogicalBorderSurface.hh"

//
//      BACCARAT includes
//
#include "BaccManager.hh"
#include "BaccDetectorComponent.hh"
#include "BaccMaterials.hh"
#include "BaccSource.hh"
#include "BaccPhysicsOpticalPhysics.hh"
#include "BaccExample8778PMT.hh"

//
//      Project includes
//
#include "XeNeuDetector.hh"
#include "XeNeuMaterials.hh"
#include "XeNeuMessenger.hh"
//#include "XeNeuDetectorParameters.hh"
#include "XeNeu_XeDetector.hh"
#include "XeNeu_MigdalNeutronTagging.hh"
#include "XeNeu_PMTCage.hh"
#include "XeNeu_LSDetector.hh"
#include "XeNeu_DDCastle.hh"
#include "XeNeu_DDBoratedPoly_1.hh"
#include "XeNeu_DDBoratedPoly_2.hh"
#include "XeNeu_VacuumBox.hh"
#include "XeNeu_TUNLShielding.hh"
#include "XeNeu_TOFDetector.hh"
//
//		Definitions
//

//using namespace XeNeuDetectorParameters;
using namespace std;


//------++++++------++++++------++++++------++++++------++++++------++++++------
//                          Detector Constructor
//------++++++------++++++------++++++------++++++------++++++------++++++------
XeNeuDetector::XeNeuDetector( G4String detName,
			G4String outVolName )
{
  detectorName = detName;
  outermostVolumeName = outVolName;
  
  XeNeumessenger = new XeNeuMessenger( this );
  
  //***DO NOT*** create another instance of XeNeuMaterials anywhere else!
  //Just refer to it using XeNeuMaterials::GetInstance().
  XeNeumaterials = XeNeuMaterials::GetInstance();
  if(!XeNeumaterials) XeNeumaterials = new XeNeuMaterials();
  //get the Bacc Materials and Nist materials
  NISTmaterials = G4NistManager::Instance();
  BACCmaterials = BaccMaterials::GetMaterials();
}

//------++++++------++++++------++++++------++++++------++++++------++++++------
//                          Detector Destructor
//------++++++------++++++------++++++------++++++------++++++------++++++------
XeNeuDetector::~XeNeuDetector()
{
  if(XeNeumessenger) delete XeNeumessenger;
  if(XeNeumaterials) delete XeNeumaterials;
}

//------++++++------++++++------++++++------++++++------++++++------++++++------
//                              InitializeDetector()
//------++++++------++++++------++++++------++++++------++++++------++++++------
void XeNeuDetector::InitializeDetector(){
  
  //if you need to access BaccManager
  BaccManager *BACCmanager = BaccManager::GetManager();
  
  //you can add the detector-specific source catalog here
  
}

//------++++++------++++++------++++++------++++++------++++++------++++++------
//                              BuildDetector()
//------++++++------++++++------++++++------++++++------++++++------++++++------
void XeNeuDetector::BuildDetector(){
  InitializeDetector();

  //this is how you access your material definition
//  G4cout<<"XeNeuMaterials example"<<G4endl;
//  G4cout<<XeNeumaterials->GetMaterialByName("liquidXe")<<G4endl<<G4endl;
 
  //Alternatively you can use the nist material database
//  G4cout<<"NistMaterials example"<<G4endl;
//  G4cout<< NISTmaterials->FindOrBuildMaterial("G4_lXe")<<G4endl<<G4endl;
  
  //another way is to use BaccMaterials
//  G4cout<<"BaccMaterials example"<<G4endl;
//  G4cout<<BACCmaterials->LiquidXe()<<G4endl<<G4endl;
 
  //  Remember that the outermost vessel is defined as a LUXSimDetector
  //	"logicalVolume".
  
  //build your detector here    
  
  //example box -- make it into a minimal working example
  G4Box * laboratory = new G4Box("laboratory", 3.4 * m, 3.4 * m,3.4 * m);
  logicalVolume  = new G4LogicalVolume(laboratory, BACCmaterials->Vacuum(), "laboratory");
  logicalVolume->SetVisAttributes( BACCmaterials->TeflonVis() );

  double detector_Z = 1.*cm;

  // Build the collimator
  XeNeu_TUNLShielding * tunl_shield_obj = new XeNeu_TUNLShielding();
  BaccDetectorComponent * tunl_shield = new BaccDetectorComponent(0,
                                            G4ThreeVector((-69.37/2.-19.05)*cm,0,0),
                                            tunl_shield_obj->GetLogicalVolume(),
                                            "tunl_shield",
                                            logicalVolume,
                                            0,0,true);
  //return;

  // Build the concrete blocks the collimator sits on
  double tunl_shield_halfx = 65.56/2. * cm;
  double tunl_shield_halfz = 71.12/2. * cm;
  G4Box * collimator_support_box = new G4Box("collimator_support_box",
                                             24.*2.54*cm, 24.*2.54*cm, 30.*2.54*cm );
  G4LogicalVolume * collimator_support_log = new G4LogicalVolume( collimator_support_box, 
                                                                  BACCmaterials->PortlandConcrete(), 
                                                                  "collimator_support_log");
  collimator_support_log->SetVisAttributes( BACCmaterials->TestRedVis() );
  BaccDetectorComponent * collimator_support = new BaccDetectorComponent(0,
                                                   G4ThreeVector((-69.37/2.-19.05)*cm + tunl_shield_halfx - 24.*2.54*cm,
                                                                 0.,
                                                                 -30.*2.54*cm - tunl_shield_halfz),
                                                   collimator_support_log,
                                                   "concrete_collimator_support",
                                                   logicalVolume,
                                                   0,0,true);


  if( tof_calibration_on ){

      // Build the PSDdetector
      double tof_x =  (-72.18)*cm + tof_calibration_distance*cm + 4.5*2.54*cm;
      double tof_y = 0.;
      XeNeu_TOFDetector * tof_detector_obj = new XeNeu_TOFDetector(0);
      G4RotationMatrix *rtof = new G4RotationMatrix();
      rtof->rotateY(-90.*deg);
      //rtof11->rotateX(det_11_ang);
      BaccDetectorComponent * tof_detector = new BaccDetectorComponent(rtof,
                                                     G4ThreeVector(tof_x,tof_y,0.),
                                                     tof_detector_obj->GetLogicalVolume(),
                                                     "tof_detector",
                                                     logicalVolume,
                                                     0,0,true);

     return;

  }



  G4RotationMatrix * det_rot = new G4RotationMatrix();
  det_rot->rotateZ(198.*deg);

  // Build the liquid xenon detector and stuff
  XeNeu_XeDetector * detector_obj = new XeNeu_XeDetector();
  BaccDetectorComponent * detector = new BaccDetectorComponent(det_rot, 
                                                       G4ThreeVector(0.,0.,detector_Z),
                                                       detector_obj->GetLogicalVolume(),
                                                       "detector",
                                                       logicalVolume,
                                                        0, 0, true);


  bool migdal_neutron_tagging = true;

  if( migdal_neutron_tagging ) {

      G4RotationMatrix * neutron_det_rot = new G4RotationMatrix();
      neutron_det_rot->rotateZ(180.*deg);

      XeNeu_MigdalNeutronTagging * migdal_tagging_detector_obj = new XeNeu_MigdalNeutronTagging();
      BaccDetectorComponent * migdal_tagging_detector = new BaccDetectorComponent( neutron_det_rot,
                                                                 G4ThreeVector(0.,0.,0.),
                                                                 migdal_tagging_detector_obj->GetLogicalVolume(),
                                                                 "migdal_neutron_tagging_detector",
                                                                 logicalVolume,
                                                                 0,0,true);
  }
  // Build the vacuum box
  double detectorHalfHeight = 7. * 2.54 * cm; 
  double vacuumBoxHalfHeight = 3. * 2.54 * cm; 
  double vacuumBoxHole_Y = (11. - 5.)*2.54 * cm;
  G4RotationMatrix * rbox = new G4RotationMatrix();
  rbox->rotateZ(180.*deg);

  XeNeu_VacuumBox * vacuum_box_obj = new XeNeu_VacuumBox();
  BaccDetectorComponent * vacuum_box = new BaccDetectorComponent(0,
                                        G4ThreeVector(0.,
                                                      vacuumBoxHole_Y,
                                                      detector_Z + detectorHalfHeight + vacuumBoxHalfHeight),
                                        vacuum_box_obj->GetLogicalVolume(),
                                        "vacuum_box",
                                        logicalVolume,
                                        0,0,true);

  // Build the aluminum base plate
  double baseplateHalfWidth = 15. * 2.54 * cm / 2.;
  double baseplateHalfLength = 26. * 2.54 * cm / 2.;
  double baseplateHalfHeight = 0.375 * 2.54 * cm / 2.;
  double baseplateHoleRadius = 5.5 * 2.54 * cm;

  G4Box * baseplate_solid = new G4Box("baseplate_solid",
                                      baseplateHalfWidth,
                                      baseplateHalfLength,
                                      baseplateHalfHeight);
  G4Tubs * baseplate_hole = new G4Tubs("baseplate_hole",
                                      0.*cm,
                                      baseplateHoleRadius,
                                      baseplateHalfHeight * 2.,
                                      0.*deg,360.*deg);
  G4SubtractionSolid * baseplate_total_solid = new G4SubtractionSolid("baseplate_total_solid",
                                      baseplate_solid,
                                      baseplate_hole,
                                      0,G4ThreeVector(0.,-5.5*2.54*cm,0.));
  G4LogicalVolume * baseplate_log = new G4LogicalVolume( baseplate_total_solid, BACCmaterials->Aluminum(), "baseplate_log");
  BaccDetectorComponent * al_baseplate = new BaccDetectorComponent(0,
                                      G4ThreeVector(0.,5.5*2.54*cm,detector_Z - detectorHalfHeight - baseplateHalfHeight - 2. * 2.54 * cm ),
                                       baseplate_log,
                                      "al_baseplate",
                                      logicalVolume,0,0,true);
 
 // Build the aluminum detector supports
 double supportRadius = 1.5/2. * 2.54 * cm;
 double supportHalfHeight = 16. * 2.54 * cm / 2.; 
 double sideSupportXOffset = baseplateHalfWidth - 0.75 * 2.54 * cm;
 double sideSupportYOffset = (22. - 5.) * 2.54 * cm;
 double frontSupportYOffset  = -(5.5 + 2. - 0.75) * 2.54 * cm;
  
 G4Tubs * al_detector_support = new G4Tubs("al_detector_suport",
                                      0.*cm,
                                      supportRadius,
                                      supportHalfHeight,
                                      0.*deg,360.*deg);
 G4LogicalVolume * al_support_log = new G4LogicalVolume( al_detector_support, BACCmaterials->Aluminum(), "al_support_log");
 BaccDetectorComponent * al_detector_support_1 = new BaccDetectorComponent(0,
                                      G4ThreeVector( 0., frontSupportYOffset, detector_Z - detectorHalfHeight - 2. * 2.54 * cm + supportHalfHeight),
                                      al_support_log,
                                      "al_detector_support_1",
                                      logicalVolume,
                                      0,0,true);
 BaccDetectorComponent * al_detector_support_2 = new BaccDetectorComponent(0,
                                      G4ThreeVector( sideSupportXOffset, sideSupportYOffset, detector_Z - detectorHalfHeight - 2. * 2.54 * cm + supportHalfHeight),
                                      al_support_log,
                                      "al_detector_support_2",
                                      logicalVolume,
                                      0,0,true);
 BaccDetectorComponent * al_detector_support_3 = new BaccDetectorComponent(0,
                                      G4ThreeVector( -sideSupportXOffset, sideSupportYOffset, detector_Z - detectorHalfHeight - 2. * 2.54 * cm + supportHalfHeight),
                                      al_support_log,
                                      "al_detector_support_3",
                                      logicalVolume,
                                      0,0,true);
  //return;
      // Build the lead shielding around the detector 
      double detectorOuterRadius  = 4.* 2.54 * cm;
      double shieldThickness = 0.476 * cm;
      double openingAngle = 14.*deg;
      double backingDetectorAngle = 52.*deg;
    
      G4Tubs * pb_det_shield_1_tubs = new G4Tubs("pb_det_shield_1_tubs",
                                           detectorOuterRadius,
                                           detectorOuterRadius + shieldThickness,
                                           detectorHalfHeight,
                                           0.,
                                           360.*deg);

      G4Box * front_hole_box = new G4Box("front_hole_box",1.*2.54*cm,0.75*2.54*cm,0.75*2.54*cm);
      G4Box * back_hole_box = new G4Box("back_hole_box",20.*cm,10.5*cm,0.75*2.54*cm);
      G4SubtractionSolid * pb_shield_minus_front_hole = new G4SubtractionSolid("pb_shield_minus_front_hole",
                                                        pb_det_shield_1_tubs,front_hole_box,0,G4ThreeVector(-4.*2.54*cm,0,-1.*cm));
      G4SubtractionSolid * pb_shield_minus_both_holes = new G4SubtractionSolid("pb_shield_minus_both_holes",
                                                        pb_shield_minus_front_hole,back_hole_box,0,
                                                        G4ThreeVector(20.*cm,0,-1.*cm));
      
      G4LogicalVolume * pb_det_shield_1_log = new G4LogicalVolume(pb_shield_minus_both_holes,
                                           BACCmaterials->Lead(),
                                            "pb_det_shield_1_log");
      pb_det_shield_1_log->SetVisAttributes( BACCmaterials->TestPurpleVis() );
      //pb_det_shield_1_log->SetVisAttributes( BACCmaterials->VacuumVis() );
      BaccDetectorComponent * pb_det_shield_1 = new BaccDetectorComponent(0,
                                           G4ThreeVector(0,0,detector_Z),
                                           pb_det_shield_1_log,
                                           "pb_det_shield_1",
                                           logicalVolume,
                                           0,0,true);
    
  //      G4Tubs * pb_det_shield_2_tubs = new G4Tubs("pb_det_shield_2_tubs",
  //                                           detectorOuterRadius,
  //                                           detectorOuterRadius + shieldThickness,
  //                                           detectorHalfHeight,
  //                                           backingDetectorAngle + openingAngle/2.,
  //                                           180.*deg - backingDetectorAngle - openingAngle);
  //      G4LogicalVolume * pb_det_shield_2_log = new G4LogicalVolume(pb_det_shield_2_tubs,
  //                                           BACCmaterials->Lead(),
  //                                            "pb_det_shield_1_log");
  //      pb_det_shield_2_log->SetVisAttributes( BACCmaterials->TestPurpleVis() );
  //      //pb_det_shield_2_log->SetVisAttributes( BACCmaterials->VacuumVis() );
  //      BaccDetectorComponent * pb_det_shield_2 = new BaccDetectorComponent(0,
  //                                           G4ThreeVector(0,0,detector_Z),
  //                                           pb_det_shield_2_log,
  //                                           "pb_det_shield_2",
  //                                           logicalVolume,
  //                                           0,0,true);


  // Build the concrete support that the detector sits on
  G4Box * detector_support_box = new G4Box("detector_support_box",
                                           8.*2.54*cm,
                                           24.*2.54*cm,
                                           32.*2.54*cm);
  G4LogicalVolume * detector_support_log = new G4LogicalVolume(detector_support_box,
                                                               BACCmaterials->PortlandConcrete(),
                                                               "detector_support_log");
  detector_support_log->SetVisAttributes( BACCmaterials->TestRedVis() );
  BaccDetectorComponent * detector_support = new BaccDetectorComponent(0,
                                                 G4ThreeVector(0,0,-30.*2.54*cm - tunl_shield_halfz+2.*2.54*cm),
                                                 detector_support_log,
                                                 "concrete_detector_support",
                                                 logicalVolume, 0,0,true);


  if( ddShieldingOn ) {

    
    
      // Build the liquid scintillator detectors
      double d_LS = 44.*cm + 4.5 * 2.54 * cm;
    
      G4RotationMatrix * rotm_ls_1 = new G4RotationMatrix();
      rotm_ls_1->rotateX(90.*deg);
      rotm_ls_1->rotateY(-(90.*deg-backingDetectorAngle));
    
      G4RotationMatrix * rotm_ls_2 = new G4RotationMatrix();
      rotm_ls_2->rotateX(90.*deg);
      rotm_ls_2->rotateY(-90.*deg - backingDetectorAngle);
    
      double PI = 3.14159265359;
      double bdAngRad = backingDetectorAngle/deg/180. * PI;
    
      XeNeu_LSDetector * ls_detector_obj = new XeNeu_LSDetector(1);
      BaccDetectorComponent * ls_detector_1 = new BaccDetectorComponent(rotm_ls_1,
                                                           G4ThreeVector(d_LS*cos(bdAngRad),d_LS*sin(bdAngRad),0.),
                                                           ls_detector_obj->GetLogicalVolume(),
                                                           "ls_detector_1",
                                                           logicalVolume,
                                                           0,0,true);
    
      BaccDetectorComponent * ls_detector_2 = new BaccDetectorComponent(rotm_ls_2,
                                                           G4ThreeVector(d_LS*cos(-bdAngRad),d_LS*sin(-bdAngRad),0.),
                                                           ls_detector_obj->GetLogicalVolume(),
                                                           "ls_detector_2",
                                                           logicalVolume,
                                                           0,0,true);
      
    
      // Build the DD shielding castle setup
      //XeNeu_DDCastle * dd_castle_obj = new XeNeu_DDCastle();
      //BaccDetectorComponent * dd_castle = new BaccDetectorComponent(0,
      //                                                     G4ThreeVector(-42.*cm,-5.625 * 2.54 * cm,0.),
      //                                                     dd_castle_obj->GetLogicalVolume(),
      //                                                     "dd_castle",
      //                                                     logicalVolume,
      //                                                     0,0,true);
    
      XeNeu_DDBoratedPoly_1 * b_poly_1_obj = new XeNeu_DDBoratedPoly_1();
    
      double boratedPoly_1_X = -42.*cm + 8.*2.54*cm + (4*2.54*cm + 0.5*cm)/2. + 5.*cm;
      double boratedPoly_1_Y = -(27.*cm/2. + 3.75*2.54*cm);
      BaccDetectorComponent * b_poly_1 = new BaccDetectorComponent(0,
                                                             G4ThreeVector(boratedPoly_1_X,boratedPoly_1_Y,0.),
                                                             b_poly_1_obj->GetLogicalVolume(),
                                                             "b_poly_1",
                                                             logicalVolume,0,0,true);
    
    
    
      XeNeu_DDBoratedPoly_2 * b_poly_2_obj = new XeNeu_DDBoratedPoly_2();
    
      double borated_poly_2_X = -42.*cm + 8.*2.54*cm + (2*2.54*cm + 1.*cm)/2.;
      double borated_poly_2_Y = 0.5*2.54*cm + 31.*cm/2.;
      BaccDetectorComponent * b_poly_2 = new BaccDetectorComponent(0,
                                                             G4ThreeVector(borated_poly_2_X,borated_poly_2_Y,0.),
                                                             b_poly_2_obj->GetLogicalVolume(),
                                                             "b_poly_2",
                                                             logicalVolume,0,0,true);
                                                        
  }


  // Build detector ID11
  double det_11_ang = 17.73*deg;
  double det_11_x = (57.88)*cm + 4.5*2.54*cm * cos(det_11_ang);
  double det_11_y = (18.5)*cm + 4.5*2.54*cm * sin(det_11_ang);
  XeNeu_TOFDetector * tof_detector_11_obj = new XeNeu_TOFDetector(11);
  G4RotationMatrix *rtof11 = new G4RotationMatrix();
  rtof11->rotateY(-90.*deg);
  rtof11->rotateX(det_11_ang);
  BaccDetectorComponent * tof_detector_11 = new BaccDetectorComponent(rtof11,
                                                 G4ThreeVector(det_11_x,det_11_y,0.),
                                                 tof_detector_11_obj->GetLogicalVolume(),
                                                 "tof_detector_11",
                                                 logicalVolume,
                                                 0,0,true);


  // Build detector ID20
  double det_20_ang = 26.10*deg;
  double det_20_x = (56.54)*cm + 4.5*2.54*cm * cos(det_20_ang);
  double det_20_y = (27.7)*cm + 4.5*2.54*cm * sin(det_20_ang);
  XeNeu_TOFDetector * tof_detector_20_obj = new XeNeu_TOFDetector(20);
  G4RotationMatrix *rtof20 = new G4RotationMatrix();
  rtof20->rotateY(-90.*deg);
  rtof20->rotateX(det_20_ang);
  BaccDetectorComponent * tof_detector_20 = new BaccDetectorComponent(rtof20,
                                                 G4ThreeVector(det_20_x,det_20_y,0.),
                                                 tof_detector_20_obj->GetLogicalVolume(),
                                                 "tof_detector_20",
                                                 logicalVolume,
                                                 0,0,true);

  
  // Build detector ID14
  double det_14_ang = 53.51*deg;
  double det_14_x = (35.06)*cm + 4.5*2.54*cm * cos(det_14_ang);
  double det_14_y = (47.4)*cm + 4.5*2.54*cm * sin(det_14_ang);
  XeNeu_TOFDetector * tof_detector_14_obj = new XeNeu_TOFDetector(14);
  G4RotationMatrix *rtof14 = new G4RotationMatrix();
  rtof14->rotateY(-90.*deg);
  rtof14->rotateX(det_14_ang);
  BaccDetectorComponent * tof_detector_14 = new BaccDetectorComponent(rtof14,
                                                 G4ThreeVector(det_14_x,det_14_y,0.),
                                                 tof_detector_14_obj->GetLogicalVolume(),
                                                 "tof_detector_14",
                                                 logicalVolume,
                                                 0,0,true);
 
  // Build detector ID2
  double det_2_ang = 15.04*deg;
  double det_2_x = (56.42)*cm + 4.5*2.54*cm * cos(det_2_ang);
  double det_2_y = (-15.3)*cm - 4.5*2.54*cm * sin(det_2_ang);
  XeNeu_TOFDetector * tof_detector_2_obj = new XeNeu_TOFDetector(2);
  G4RotationMatrix *rtof2 = new G4RotationMatrix();
  rtof2->rotateY(-90.*deg);
  rtof2->rotateX(-det_2_ang);
  BaccDetectorComponent * tof_detector_2 = new BaccDetectorComponent(rtof2,
                                                 G4ThreeVector(det_2_x,det_2_y,0.),
                                                 tof_detector_2_obj->GetLogicalVolume(),
                                                 "tof_detector_2",
                                                 logicalVolume,
                                                 0,0,true);

  // Build detector ID15
  double det_15_ang = 27.41*deg;
  double det_15_x = (54.38)*cm + 4.5*2.54*cm * cos(det_15_ang);
  double det_15_y = (-28.2)*cm - 4.5*2.54*cm * sin(det_15_ang);
  XeNeu_TOFDetector * tof_detector_15_obj = new XeNeu_TOFDetector(15);
  G4RotationMatrix *rtof15 = new G4RotationMatrix();
  rtof15->rotateY(-90.*deg);
  rtof15->rotateX(-det_15_ang);
  BaccDetectorComponent * tof_detector_15 = new BaccDetectorComponent(rtof15,
                                                 G4ThreeVector(det_15_x,det_15_y,0.),
                                                 tof_detector_15_obj->GetLogicalVolume(),
                                                 "tof_detector_15",
                                                 logicalVolume,
                                                 0,0,true);


  // Build detector ID5
  double det_5_ang = 35.09*deg;
  double det_5_x = (47.16)*cm + 4.5*2.54*cm * cos(det_5_ang);
  double det_5_y = (-33.7)*cm - 4.5*2.54*cm * sin(det_5_ang);
  XeNeu_TOFDetector * tof_detector_5_obj = new XeNeu_TOFDetector(5);
  G4RotationMatrix *rtof5 = new G4RotationMatrix();
  rtof5->rotateY(-90.*deg);
  rtof5->rotateX(-det_5_ang);
  BaccDetectorComponent * tof_detector_5 = new BaccDetectorComponent(rtof5,
                                                 G4ThreeVector(det_5_x,det_5_y,0.),
                                                 tof_detector_5_obj->GetLogicalVolume(),
                                                 "tof_detector_5",
                                                 logicalVolume,
                                                 0,0,true);


  // Build detector ID21
  double det_21_ang = 47.84*deg;
  double det_21_x = (38.57)*cm + 4.5*2.54*cm * cos(det_21_ang);
  double det_21_y = (-43.8)*cm - 4.5*2.54*cm * sin(det_21_ang);
  XeNeu_TOFDetector * tof_detector_21_obj = new XeNeu_TOFDetector(21);
  G4RotationMatrix *rtof21 = new G4RotationMatrix();
  rtof21->rotateY(-90.*deg);
  rtof21->rotateX(-det_21_ang);
  BaccDetectorComponent * tof_detector_21 = new BaccDetectorComponent(rtof21,
                                                 G4ThreeVector(det_21_x,det_21_y,0.),
                                                 tof_detector_21_obj->GetLogicalVolume(),
                                                 "tof_detector_21",
                                                 logicalVolume,
                                                 0,0,true);

  // Build detector ID8
  double det_8_ang = 62.10*deg;
  double det_8_x = (28.43)*cm + 4.5*2.54*cm * cos(det_8_ang);
  double det_8_y = (-53.7)*cm - 4.5*2.54*cm * sin(det_8_ang);
  XeNeu_TOFDetector * tof_detector_8_obj = new XeNeu_TOFDetector(8);
  G4RotationMatrix *rtof8 = new G4RotationMatrix();
  rtof8->rotateY(-90.*deg);
  rtof8->rotateX(-det_8_ang);
  BaccDetectorComponent * tof_detector_8 = new BaccDetectorComponent(rtof8,
                                                 G4ThreeVector(det_8_x,det_8_y,0.),
                                                 tof_detector_8_obj->GetLogicalVolume(),
                                                 "tof_detector_8",
                                                 logicalVolume,
                                                 0,0,true);



  // Build detector 7L
  double det_7l_ang = 39.98*deg;
  double det_7l_x = (43.64)*cm + 4.5*2.54*cm * cos(det_7l_ang);
  double det_7l_y = 36.6*cm + 4.5*2.54*cm * sin(det_7l_ang);
  XeNeu_LSDetector * ls_detector_7l_obj = new XeNeu_LSDetector(71);
  G4RotationMatrix * rls7l = new G4RotationMatrix();
  rls7l->rotateX(90.*deg);
  rls7l->rotateY(-(90.*deg-det_7l_ang));
  BaccDetectorComponent * ls_detector_7l = new BaccDetectorComponent(rls7l,
                                                 G4ThreeVector(det_7l_x,det_7l_y,1.*2.54*cm),
                                                 ls_detector_7l_obj->GetLogicalVolume(),
                                                 "ls_detector_7l",
                                                 logicalVolume,
                                                 0,0,true);


  // Build detector 8L
  double det_8l_ang = 69.38*deg;
  double det_8l_x = (22.35)*cm + 4.5*2.54*cm*cos(det_8l_ang);
  double det_8l_y = 59.4*cm + 4.5*2.54*cm * sin(det_8l_ang);
  XeNeu_LSDetector * ls_detector_8l_obj = new XeNeu_LSDetector(81);
  G4RotationMatrix * rls8l = new G4RotationMatrix();
  rls8l->rotateX(90.*deg);
  rls8l->rotateY(-(90.*deg-det_8l_ang));
  BaccDetectorComponent * ls_detector_8l = new BaccDetectorComponent(rls8l,
                                                 G4ThreeVector(det_8l_x,det_8l_y,1.*2.54*cm),
                                                 ls_detector_8l_obj->GetLogicalVolume(),
                                                 "ls_detector_8l",
                                                 logicalVolume,
                                                 0,0,true);


  // Add lead sheet 
  G4Box * lead_sheet_box = new G4Box("lead_sheet_box",
                                     3.35*mm,
                                     3.*2.54*cm,
                                     5.*2.54*cm);
  G4LogicalVolume * lead_sheet_log = new G4LogicalVolume( lead_sheet_box, BACCmaterials->Lead(), "lead_sheet_log" );
  lead_sheet_log->SetVisAttributes( BACCmaterials->TestPurpleVis() );
  BaccDetectorComponent * lead_sheet = new BaccDetectorComponent(0,
                                                G4ThreeVector( -8.*2.54*cm, 0., 0. ),
                                                lead_sheet_log,
                                                "lead_sheet",
                                                logicalVolume,
                                                0,0,true);
 
   
  // Add lead bricks
  G4Box * lead_brick_box = new G4Box("lead_brick_box",
                                    1.*2.54*cm,
                                    2.*2.54*cm,
                                    4.*2.54*cm);
  G4LogicalVolume * lead_brick_log = new G4LogicalVolume( lead_brick_box, BACCmaterials->Lead(), "lead_brick_log");
  lead_brick_log->SetVisAttributes( BACCmaterials->TestPurpleVis() );
  BaccDetectorComponent * lead_brick_1 = new BaccDetectorComponent(0,
                                               G4ThreeVector(-5.3*2.54*cm,(2.7/2.+2.*2.54)*cm,0.),
                                               lead_brick_log,
                                               "lead_brick_1",
                                               logicalVolume,
                                               0,0,true);
  BaccDetectorComponent * lead_brick_2 = new BaccDetectorComponent(0,
                                               G4ThreeVector(-5.3*2.54*cm,-(2.7/2.+2.*2.54)*cm,0.),
                                               lead_brick_log,
                                               "lead_brick_2",
                                               logicalVolume,
                                               0,0,true);


}

//------++++++------++++++------++++++------++++++------++++++------++++++------
//                                      SetOrigin()
//------++++++------++++++------++++++------++++++------++++++------++++++------
G4ThreeVector XeNeuDetector::SetOrigin(BaccDetectorComponent *ExpHall){
  //you need to implement this function here
  return G4ThreeVector(0,0,0);
}
