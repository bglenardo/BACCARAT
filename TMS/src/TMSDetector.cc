////////////////////////////////////////////////////////////////////////////////
//
// This code is automatically generated by BACCARAT to define TMS geometry
//
////////////////////////////////////////////////////////////////////////////////
//
//      Change log
// 17 March 2016 - Initial Template submission (Jingke)
//
////////////////////////////////////////////////////////////////////////////////

//
//      C/C++ includes
//
#include <sstream>
#include <ctime>
#include <iostream>

//
//      GEANT4 includes
//
#include "G4SystemOfUnits.hh"
#include "G4LogicalVolume.hh"
#include "G4Material.hh"
#include "G4NistManager.hh"
#include "G4RotationMatrix.hh"
//#include "G4Tubs.hh"
#include "G4Box.hh"
//#include "G4Torus.hh"
//#include "G4CutTubs.hh"
//#include "G4Ellipsoid.hh"
//#include "G4Polyhedra.hh"
//#include "G4Cons.hh"
#include "G4SubtractionSolid.hh"
//#include "G4UnionSolid.hh"
//#include "G4IntersectionSolid.hh"
//#include "G4OpticalSurface.hh"
//#include "G4LogicalBorderSurface.hh"

//
//      BACCARAT includes
//
#include "BaccManager.hh"
#include "BaccDetectorComponent.hh"
#include "BaccMaterials.hh"
#include "BaccSource.hh"
//#include "BaccPhysicsOpticalPhysics.hh"

//
//      Project includes
//
#include "TMSDetector.hh"
#include "TMSMaterials.hh"
#include "TMSMessenger.hh"
#include "TMS_TPC.hh"
#include "TMS_LSDetector.hh"
#include "TMS_PSD_Detector.hh"
#include "TMS_NaI_Detector_5in.hh"
#include "TMS_AmBeShield.hh"
#include "TMS_AmBeBoratedPEShield.hh"
#include "TMS_AmBeBoratedPEShieldGamma.hh"
#include "TMS_AmBeBoratedPEShieldDDGun.hh"
//
//		Definitions
//

//using namespace TMSDetectorParameters;
using namespace std;


//------++++++------++++++------++++++------++++++------++++++------++++++------
//                          Detector Constructor
//------++++++------++++++------++++++------++++++------++++++------++++++------
TMSDetector::TMSDetector( G4String detName,
			G4String outVolName )
{

  cerr << "Inside TMSDetector constructor!!" << endl;
  detectorName = detName;
  outermostVolumeName = outVolName;
  
  TMSmessenger = new TMSMessenger( this );
  
  //***DO NOT*** create another instance of TMSMaterials anywhere else!
  //Just refer to it using TMSMaterials::GetInstance().
  TMSmaterials = TMSMaterials::GetInstance();
  if(!TMSmaterials) TMSmaterials = new TMSMaterials();
  //get the Bacc Materials and Nist materials
  NISTmaterials = G4NistManager::Instance();
  BACCmaterials = BaccMaterials::GetMaterials();
}

//------++++++------++++++------++++++------++++++------++++++------++++++------
//                          Detector Destructor
//------++++++------++++++------++++++------++++++------++++++------++++++------
TMSDetector::~TMSDetector()
{
  if(TMSmessenger) delete TMSmessenger;
  if(TMSmaterials) delete TMSmaterials;
}

//------++++++------++++++------++++++------++++++------++++++------++++++------
//                              InitializeDetector()
//------++++++------++++++------++++++------++++++------++++++------++++++------
void TMSDetector::InitializeDetector(){
  
  //if you need to access BaccManager
  BaccManager *BACCmanager = BaccManager::GetManager();
  
  //you can add the detector-specific source catalog here
  
}

//------++++++------++++++------++++++------++++++------++++++------++++++------
//                              BuildDetector()
//------++++++------++++++------++++++------++++++------++++++------++++++------
void TMSDetector::BuildDetector(){

  cerr << "\nInside BuildDetector of TMSDetector...\n" << endl;

  InitializeDetector();

  //this is how you access your material definition
//  G4cout<<"TMSMaterials example"<<G4endl;
//  G4cout<<TMSmaterials->GetMaterialByName("liquidXe")<<G4endl<<G4endl;
 
  //Alternatively you can use the nist material database
//  G4cout<<"NistMaterials example"<<G4endl;
//  G4cout<< NISTmaterials->FindOrBuildMaterial("G4_lXe")<<G4endl<<G4endl;
  
  //another way is to use BaccMaterials
//  G4cout<<"BaccMaterials example"<<G4endl;
//  G4cout<<BACCmaterials->LiquidXe()<<G4endl<<G4endl;
 
  //  Remember that the outermost vessel is defined as a LUXSimDetector
  //	"logicalVolume".
  
  //build your detector here    
  
  //example box -- make it into a minimal working example
  G4Box * example_box = new G4Box("example_box", 5*m,5*m,5*m);
  logicalVolume  = new G4LogicalVolume(example_box, BACCmaterials->Vacuum(), "example_log");
  logicalVolume->SetVisAttributes( BACCmaterials->VacuumVis() );


  G4Box * lab_space_box = new G4Box("lab_space",4*m,4*m,4*m);
  G4LogicalVolume * lab_space_log = new G4LogicalVolume( lab_space_box, BACCmaterials->Vacuum(), "lab_space");
  lab_space_log->SetVisAttributes( BACCmaterials->VacuumVis() );
  BaccDetectorComponent* lab_space = new BaccDetectorComponent(0,
                                            G4ThreeVector(0,0,0),
                                            lab_space_log,
                                            "lab_space",
                                            logicalVolume,
                                            0,0,true);
                                            

  double detectorXoffset = 50.8*cm;
  //double detectorXoffset = 0.*cm;
  G4RotationMatrix * detector_rot = new G4RotationMatrix();
  detector_rot->rotateY(5.*deg);
  detector_rot->rotateX(90.*deg);


  TMS_TPC * detector_obj = new TMS_TPC();
  BaccDetectorComponent * detector = new BaccDetectorComponent(detector_rot,
                                             G4ThreeVector(detectorXoffset,0.,0.),
                                             detector_obj->GetLogicalVolume(),
                                             "detector",
                                             lab_space_log,
                                             0,0,true);



  ////////////////////////////////////////////////////////////////////////////////////////
  // Plastic scintillator detectors for DD neutron tagging measurements
  double d_PSD = 40.*cm; //25.*cm + 4.5 * 2.54 * cm;
  double backingDetectorAngle = 70.*deg;

  double bdAngRad = backingDetectorAngle/deg/180. * 3.1415926;

  // First liquid scintillator detector
  G4RotationMatrix * rotm_psd_1 = new G4RotationMatrix();
  rotm_psd_1->rotateX(90.*deg);
  rotm_psd_1->rotateY(-(90.*deg+backingDetectorAngle));
  TMS_PSD_Detector * lsdet_obj = new TMS_PSD_Detector("1");
  BaccDetectorComponent * lsdet1 = new BaccDetectorComponent(rotm_psd_1,
                                            G4ThreeVector(detectorXoffset+d_PSD*cos(bdAngRad),-d_PSD*sin(bdAngRad),0.),
                                            lsdet_obj->GetLogicalVolume(),
                                            "ls_det_1",
                                            lab_space_log,
                                            0,0,true);

  // Second liquid scintillator detector
  G4RotationMatrix * rotm_psd_2 = new G4RotationMatrix();
  //rotm_psd_2->rotateZ(90.*deg-backingDetectorAngle);
  rotm_psd_2->rotateY(-(90.*deg+backingDetectorAngle));
  TMS_PSD_Detector * lsdet_obj_2 = new TMS_PSD_Detector("2");
  BaccDetectorComponent * lsdet2 = new BaccDetectorComponent(rotm_psd_2,
                                            G4ThreeVector(detectorXoffset + d_PSD*cos(bdAngRad),0.,-d_PSD*sin(bdAngRad)),
                                            lsdet_obj_2->GetLogicalVolume(),
                                            "ls_det_2",
                                            lab_space_log,
                                            0,0,true);
  /////////////////////////////////////////////////////////////////////////////////////////////


//  //////////////////////////////////////////////////////////////////////////////////////////////
//  // Sodium Iodide and two PS detectors from the pair production measurements.
//  G4RotationMatrix * rotm_psd_3 = new G4RotationMatrix();
//  rotm_psd_3->rotateY(-(90.*deg + backingDetectorAngle));
//  TMS_NaI_Detector_5in * lsdet_obj_3 = new TMS_NaI_Detector_5in("3");
//  BaccDetectorComponent * lsdet3 = new BaccDetectorComponent(rotm_psd_3,
//                                            G4ThreeVector(detectorXoffset+d_PSD*cos(bdAngRad),0.,-d_PSD*sin(bdAngRad)),
//                                            lsdet_obj_3->GetLogicalVolume(),
//                                            "nai_det_3",
//                                            lab_space_log,
//                                            0,0,true);
//  G4RotationMatrix * rotm_ls = new G4RotationMatrix();
//
//  rotm_ls->rotateY( -90.*deg );
//  TMS_LSDetector * lsdet_obj = new TMS_LSDetector("0");
//  BaccDetectorComponent * lsdet0 = new BaccDetectorComponent(rotm_ls,
//					    G4ThreeVector(detectorXoffset + 2.5*2.54*cm, 0., 15.*cm),
//					    lsdet_obj->GetLogicalVolume(),
//					    "ls_det_0",
//					    lab_space_log,
//					    0,0,true);
////  rotm_ls->rotateY( -90.*deg );
//  TMS_LSDetector * lsdet_obj_1 = new TMS_LSDetector("1");
//  BaccDetectorComponent * lsdet1 = new BaccDetectorComponent(rotm_ls,
//					    G4ThreeVector(detectorXoffset + 2.5*2.54*cm, 0., 20.58*cm),
//					    lsdet_obj_1->GetLogicalVolume(),
//					    "ls_det_1",
//					    lab_space_log,
//					    0,0,true);
//  ///////////////////////////////////////////////////////////////////////////////////////////
  



//  // Fourth liquid scintillator detector
//  G4RotationMatrix * rotm_psd_4 = new G4RotationMatrix();
//  rotm_psd_4->rotateY(-(90.*deg - backingDetectorAngle));
//  TMS_PSD_Detector * lsdet_obj_4 = new TMS_PSD_Detector("4");
//  BaccDetectorComponent * lsdet4 = new BaccDetectorComponent(rotm_psd_4,
//                                            G4ThreeVector(detectorXoffset+d_PSD*cos(bdAngRad),0.,d_PSD*sin(bdAngRad)),
//                                            lsdet_obj_4->GetLogicalVolume(),
//                                            "ls_det_4",
//                                            lab_space_log,
//                                            0,0,true);
  

  TMS_AmBeBoratedPEShieldDDGun * shield_obj = new TMS_AmBeBoratedPEShieldDDGun();
  BaccDetectorComponent * source_shield = new BaccDetectorComponent(0,
                                              G4ThreeVector(0.,1.*cm,0.),
                                              shield_obj->GetLogicalVolume(),
                                              "source_shield",
                                              lab_space_log,
                                              0,0,true); 
 
  // Borated poly blocks that Shuoxing added to block direct-path neutrons
//  G4Box  * bpe_front_block_box = new G4Box("bpe_front_block_box",
//                                              1.5 * 2.54 * cm,
//                                              6. * 2.54 * cm,
//                                              19./2. * 2.54 * cm);
//  G4LogicalVolume * bpe_front_block_log = new G4LogicalVolume( bpe_front_block_box, TMSmaterials->BoratedPE_LD(), 
//                                                               "bpe_front_block_log");
//  bpe_front_block_log->SetVisAttributes( BACCmaterials->TestGreenVis() );
//  BaccDetectorComponent * bpe_front_block_1 = new BaccDetectorComponent(0,
//                                              G4ThreeVector(14.5*2.54*cm,7.*2.54*cm,-5.*2.54*cm),
//                                              bpe_front_block_log,
//                                              "bpe_front_block_1",
//                                              lab_space_log,
//                                              0,0,true);
//  
//  BaccDetectorComponent * bpe_front_block_2 = new BaccDetectorComponent(0,
//                                              G4ThreeVector(14.5*2.54*cm,-7.*2.54*cm,-5.*2.54*cm),
//                                              bpe_front_block_log,
//                                              "bpe_front_block_2",
//                                              lab_space_log,
//                                              0,0,true);
//  
//  G4Box * bpe_under_block_box = new G4Box("bpe_under_block_box",
//                                           2.5*2.54*cm,
//                                           13.*2.54*cm,
//                                           4.25*2.54*cm);
//  G4LogicalVolume * bpe_under_block_log = new G4LogicalVolume( bpe_under_block_box, TMSmaterials->BoratedPE_LD(),
//                                                               "bpe_under_block_log" );
//  bpe_under_block_log->SetVisAttributes( BACCmaterials->TestGreenVis() );
//  BaccDetectorComponent * bpe_under_block = new BaccDetectorComponent(0,
//                                           G4ThreeVector(18.5*2.54*cm,0.,-10.*2.54*cm),
//                                           bpe_under_block_log,
//                                           "bpe_under_block",
//                                           lab_space_log,
//                                           0,0,true);
//  
//  // Al plate underneath detector
//  G4Box * al_plate_box = new G4Box("al_plate_box",
//                                   2.*2.54*cm,
//                                   13.*2.54*cm,
//                                   1.5/8.*2.54*cm);
//  G4LogicalVolume * al_plate_log = new G4LogicalVolume( al_plate_box, BACCmaterials->Aluminum(), "al_plate_log");
//  BaccDetectorComponent * al_plate = new BaccDetectorComponent(0,
//                                            G4ThreeVector(detectorXoffset-1.*2.54*cm,0.,-(4.+3./16.)*2.54*cm),
//                                            al_plate_log,
//                                            "al_plate",
//                                            lab_space_log,
//                                            0,0,true);
//  
//  
//  // Unistrut support under TMS detector
//  G4Box * unistrut_shell_box = new G4Box("unistrut_large_box",
//                                         1.625/2.*2.54*cm,
//                                         13.*2.54*cm,
//                                         1.625/2.*2.54*cm);
//  G4Box * unistrut_cutout_box = new G4Box("unistrut_cutout_box",
//                                         1.625/2.*2.54*cm,
//                                         14.*2.54*cm,
//                                         1.625/2.*2.54*cm - 2.7*mm);
//  G4SubtractionSolid * unistrut_volume_sub = new G4SubtractionSolid("unistrut_volume_sub",
//                                                                    unistrut_shell_box,
//                                                                    unistrut_cutout_box,
//                                                                    0,
//                                                                    G4ThreeVector(2.7*mm,0.,0.));
//  G4LogicalVolume * unistrut_log = new G4LogicalVolume( unistrut_volume_sub, BACCmaterials->Steel(),"unistrut_log");
//  
//  BaccDetectorComponent * unistrut = new BaccDetectorComponent(0,
//                                         G4ThreeVector(detectorXoffset + (1.+1.625/2.)*2.54*cm,
//                                                       0.,
//                                                       -(4.+1.625/2.)*2.54*cm),
//                                         unistrut_log,
//                                         "unistrut",
//                                         lab_space_log,
//                                         0,0,true);

}

//------++++++------++++++------++++++------++++++------++++++------++++++------
//                                      SetOrigin()
//------++++++------++++++------++++++------++++++------++++++------++++++------
G4ThreeVector TMSDetector::SetOrigin(BaccDetectorComponent *ExpHall){
  //you need to implement this function here
  return G4ThreeVector(0,0,0);
}
